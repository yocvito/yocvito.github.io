+++
title = "Rust proc-macros based obfuscation"
author = ""
authorTwitter = "" #do not include @
cover = ""
tags = ["project", "demo", "obfuscation", "kobalos", "rust"]
keywords = ["project", "demo", "obfuscation", "kobalos", "rust"]
description = "Implementing the Kobalos malware obfuscation technique using Rust proc-macros"
showFullContent = false
readingTime = false
hideComments = false
+++

# Kobalos Obfuscation in Rust

Obfuscate functions using kobalos style.

⚠️ **WARNING** ⚠️<span style="line-height:2;"></span>   
_This is really a WIP project I just started with almost nothing working yet. Code samples here are hand-crafted and not generated by the lib except for the last example (which is not working anyway). This is to show that it seems feasible in Rust even though it requires a bit of work._


## Usage

Tag your function with `#[kobalos::obfuscate]` attribute macro to obfuscate it.

```rust
#[kobalos::obfuscate]
fn foo() {
    println!("Hello, world!");
}
```

would be transformed into:

```rust
enum RecArg<'a> {
    RAVoid,
    RARefStr(&'a str),
}

// From & Into implementations for all `RecArg` variants
// ...

fn __recursive_foo(id: u32, args: Vec<RecArg>) -> RecArg {
    match id {
        0 => {
            let () = match &args[..] {
                [RecArg::RAVoid] => (),
                _ => panic!("Invalid argument type"),
            };
            __recursive_foo(1, vec![RecArg::RARefStr("Hello, world!")])
        },
        1 => {
            let s = match &args[..] {
                [RecArg::RARefStr(s)] => s,
                _ => panic!("Invalid argument type"),
            };
            println!("{}", s);
            RecArg::RAVoid
        },
        _ => panic!("Invalid function id"),
    }
}

fn foo() {
    __recursive_foo(0, vec![RecArg::RAVoid])
}
```

If the obfuscated function contains calls to functions belonging to the program itself,
the obfuscator will then manage to inline them into the recursive function.

```rust
fn bar(a: u32) {
    a+1
}

#[kobalos::obfuscate]
fn foo() {
    println!("{}", bar(1));
}
```

would be transformed into:

```rust
enum RecArg<'a> {
    RAVoid,
    RAU32(u32),
}

// From & Into implementations for all `RecArg` variants
// ...

fn __recursive_foo(id: u32, args: Vec<RecArg>) -> RecArg {
    match id {
        0 => {
            let () = match &args[..] {
                [RecArg::RAVoid] => (),
                _ => panic!("Invalid argument type"),
            };
            let fcret0 = __recursive_foo(1, vec![RecArg::RAU32(1)]);
            __recursive_foo(2, vec![fcret0])
        },
        1 => {
            let a = match &args[..] {
                [RecArg::RAU32(a)] => a,
                _ => panic!("Invalid argument type"),
            };
            // no call to bar() 
            let ret = a+1;
            RecArg::RAU32(ret)
        },
        2 => {
            let v0 = match args {
                [RecArg::RAU32(v)] => v,
                _ => panic!("Invalid argument type"),
            };
            println!("{}", v0);
            RecArg::RAVoid
        },
        _ => panic!("Invalid function id"),
    }
}

fn foo() {
    __recursive_foo(0, vec![RecArg::RAVoid])
}
```

## Implementation insights

### Explanations

The library is supposed to analyze the obfuscated function and catch all calls (functions or methods) in order to obfuscate them in a newly created recursive function (inlining functions present in the program code). 

By recursively obfuscating all inlined functions, it can theorically pack the whole codebase into one function. This function would be called with an `ID` (representing the function to be called) and a vector containing the arguments for the function.


The library should infers on the argument types of the called functions in order to create a common enum type (`RecArg`) which handles all possible function argument types for obfuscated calls.

Writing IDA or Ghidra scripts to reverse the logic should be easy enough, so an advanced version would include random or mutating IDs (like the one in the call wouldn't correspond to the actual match case ID). But at the end, everything is reversable...

### Real Example

This shows code generated by a PoC library I've started writing. The code doesn't actually compile yet because lot of things need to be handled in order to fully wrap all called functions into match statements + inlining correctly all the functions present in the program.

**original code:**

```rust
use std::io::Write;

use kobalos_obfuscator::obfuscate;

fn get_toto() -> &'static str {
    "toto"
}

fn toto() {
    println!("{}", get_toto());
}

fn display(s: &Vec<u8>) {
    std::io::stdout().write_all(s).unwrap();
}

#[obfuscate]
fn main() {
    let vec: Vec<u8> = vec![0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21];
    print!("I'm "); toto();
    display(&vec);
}
```

**generated code:**
```rust
pub enum RecArg<'a> {
    RARefVecU8(&'a Vec<u8>),
    RAVoid,
}
impl<'a> From<&'a Vec<u8>> for RecArg<'a> {
    fn from(val: &'a Vec<u8>) -> Self {
        RecArg::RARefVecU8(val)
    }
}
impl<'a> Into<&'a Vec<u8>> for RecArg<'a> {
    fn into(self) -> &'a Vec<u8> {
        match self {
            RecArg::RARefVecU8(val) => val,
            _ => panic!("Invalid conversion"),
        }
    }
}
impl<'a> From<()> for RecArg<'a> {
    fn from(_: ()) -> Self {
        RecArg::RAVoid
    }
}
impl<'a> Into<()> for RecArg<'a> {
    fn into(self) -> () {
        match self {
            RecArg::RAVoid => (),
            _ => panic!("Invalid conversion"),
        }
    }
}
fn __recursive_main(id: u32, args: Vec<RecArg>) -> RecArg {
    match id {
        1u32 => {
            let () = match args.as_slice() {
                [] => (),
                _ => return panic!("Bruh"),
            };
            {
                println!("{}", get_toto());
            }
            RecArg::RAVoid
        }
        2u32 => {
            let (s) = match args.as_slice() {
                [RecArg::RARefVecU8(s)] => (s),
                _ => return panic!("Bruh"),
            };
            {
                std::io::stdout().write_all(s).unwrap();
            }
            RecArg::RAVoid
        }
        0u32 => {
            {
                let vec: Vec<u8> = vec![
                    0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x2c, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21,
                ];
                print!("I'm ");
                __recursive_main(1, vec![]);
                __recursive_main(2, vec![RecArg::RARefVecU8(&vec)]);
            }
            RecArg::RAVoid
        }
        _ => panic!("Ho Ho Ho"),
    }
}
fn main() {
    __recursive_main(0, vec![]).into()
}
```

Here is the IDA cfg of both non-obfuscated and obfuscated versions (not using the same version that generated above code). Of course it doesn't seems so usefull for simple functions like that, but I think it would be more powerfull on big functions.

**not-obfuscated cfg:**

![non-obfuscated cfg](/img/kobalos-rs/cfg-not-obfuscated.png)

**obfuscated cfg:**


![obfuscated cfg](/img/kobalos-rs/cfg-obfuscated.png)
